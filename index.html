<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Wireframe Continents Globe</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #ffffff; }
    #globeViz { width: 100vw; height: 100vh; }
    #globeViz canvas { background: #fff !important; }
  </style>
  <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
  <script src="https://unpkg.com/globe.gl@2.26.0/dist/globe.gl.min.js"></script>
</head>
<body>
  <div id="globeViz"></div>
  <script>
    const el = document.getElementById('globeViz');
    const globe = Globe()(el);

    // Masque des continents (blanc=terre, noir=mer)
    const maskUrl = 'https://raw.githubusercontent.com/cecitecontact-rgb/audiostory/main/continents-mask.png';
    
    // Crée une géométrie très segmentée pour wireframe dense
    const globeRadius = globe.getGlobeRadius ? globe.getGlobeRadius() : 1; // fallback si getGlobeRadius absent
    const geo = new THREE.SphereGeometry(globeRadius, 128, 128);

    // Matériau wireframe, alphaTest pour masquer la mer
    const texture = new THREE.TextureLoader().load(maskUrl, function() {
      globe.scene().background = new THREE.Color(0xffffff);
      globe.renderer().setClearColor(0xffffff, 1);
    });

    const mat = new THREE.MeshBasicMaterial({
      wireframe: true,
      map: texture,
      alphaTest: 0.5, // n'affiche que là où le masque est blanc
      color: 0x222222
    });

    // Remplace le globe par la géométrie custom et le matériau
    globe.globeGeometry(geo);
    globe.globeMaterial(mat);
    globe.globeImageUrl(null);
    globe.bumpImageUrl(null);

    // Lumière
    const scene = globe.scene();
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 3, 5);
    scene.add(dir);

    // Épingles
    const pins = [
      { lat: 48.8566, lng: 2.3522, name: 'Paris' },
      { lat: 52.52,   lng: 13.405, name: 'Berlin' },
      { lat: 40.7128, lng: -74.0060, name: 'New York' }
    ];

    globe
      .customLayerData(pins)
      .customThreeObject(d => {
        const r = 0.0075;
        const h = 0.35;
        const mat = new THREE.MeshStandardMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.8
        });
        const geo = new THREE.CylinderGeometry(r, r, h, 8);
        return new THREE.Mesh(geo, mat);
      })
      .customThreeObjectUpdate((obj, d) => {
        const { lat, lng } = d;
        const phi = (90 - lat) * Math.PI / 180;
        const theta = (lng + 180) * Math.PI / 180;
        const R = globe.getGlobeRadius();

        const x = R * Math.sin(phi) * Math.cos(theta);
        const y = R * Math.cos(phi);
        const z = R * Math.sin(phi) * Math.sin(theta);
        obj.position.set(x, y, z);

        const normal = obj.position.clone().normalize();
        obj.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
        obj.position.multiplyScalar(1.02);
      });

    globe.controls().autoRotate = true;
    globe.controls().autoRotateSpeed = 0.6;
    globe.pointLabel(() => null);
  </script>
</body>
</html>
