<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Globe Wireframe + Épingles sobres</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #ffffff; } /* fond blanc */
    #globeViz { width: 100vw; height: 100vh; }
  </style>
  <script src="https://unpkg.com/three"></script>
  <script src="https://unpkg.com/globe.gl"></script>
</head>
<body>
  <div id="globeViz"></div>

  <script>
    const el = document.getElementById('globeViz');
    const globe = Globe()(el);

    // Pas de texture -> base neutre
    globe.globeImageUrl(null);
    globe.bumpImageUrl(null);

    // Modifier le matériau
    const mat = globe.globeMaterial();
    mat.wireframe = true;                       // fil de fer
    mat.color = new THREE.Color(0x333333);      // gris sombre pour contraste
    mat.roughness = 1;
    mat.metalness = 0;

    // Fond blanc dans la scène
    globe.scene().background = new THREE.Color(0xffffff);

    // Lumière chaude
    const scene = globe.scene();
    scene.add(new THREE.AmbientLight(0xffcc66, 0.35));
    const dir = new THREE.DirectionalLight(0xffc87c, 1.1);
    dir.position.set(5, 3, 5);
    scene.add(dir);

    // Épingles sobres
    const pins = [
      { lat: 48.8566, lng: 2.3522, name: 'Paris' },
      { lat: 52.52,   lng: 13.405, name: 'Berlin' },
      { lat: 40.7128, lng: -74.0060, name: 'New York' }
    ];

    globe
      .customLayerData(pins)
      .customThreeObject(d => {
        const r = 0.0075;
        const h = 0.35;
        const geo = new THREE.CylinderGeometry(r, r, h, 8);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x000000, transparent: true, opacity: 0.7
        });
        return new THREE.Mesh(geo, mat);
      })
      .customThreeObjectUpdate((obj, d) => {
        const { lat, lng } = d;
        const phi   = (90 - lat) * Math.PI / 180;
        const theta = (lng + 180) * Math.PI / 180;
        const R = globe.getGlobeRadius();

        const x = R * Math.sin(phi) * Math.cos(theta);
        const y = R * Math.cos(phi);
        const z = R * Math.sin(phi) * Math.sin(theta);
        obj.position.set(x, y, z);

        const normal = obj.position.clone().normalize();
        obj.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
        obj.position.multiplyScalar(1.02);
      });

    // Rotation douce
    globe.controls().autoRotate = true;
    globe.controls().autoRotateSpeed = 0.6;

    globe.pointLabel(() => null);
  </script>
</body>
</html>
